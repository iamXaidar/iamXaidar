# Мое понимание метаклассов
* краткий конспект на базе множества источников

Метакласс это программный элемент для создания класса.
Метакласс представлен функцией ```type()``` — которая может принимать один или три параметра.

Когда функция принимает один параметр, это может быть класс или объект. Функция вернет название класса этого объекта. 

В случае если в ```type()``` единственным аргументом передать класс, функция вернет ```<class ‘type’>```, так как все классы в Python являются объектами класса type.

Если в функцию ```type()``` передать три аргумента, будет создан класс (динамически) и функция вернет ссылку на него. В таком случае в качестве первого аргумента передается имя создаваемого класса, вторым кортеж с родительскими классами и третьим передается словарь с атрибутами класса.

Если вспомнить, что методы тоже являются атрибутами, их тоже можно передать в коллекции атрибутов класса.
## Два способа создания класса
```
1. class Main(Parent):
    	    x = 1
    	    y = 2
	    def __init__(self, z: int):
	        self.z = z

2. def __init__(self, z: int):
    self.z = z

Main = type(“Main”, (Parent,), {“x”: 1, “y”: 2, “__init__”: __init__})
```
## Пользовательский метакласс
Если наследовать класс от объекта ```type```, можно создавать пользовательские метаклассы. 

Пользовательский метакласс можно передать в качестве параметра ```metaclass``` при создании класса:
```
class Point(metaclass=CustomMetaClass):
	pass
```
В пользовательском метаклассе можно переопределить логику работы всех методов метакласса ```type```.

Каждый раз при создании класса, интерпретатор смотрит задан ли параметр ```metaclass```. Если нет он ищет его во все суперклассах. Если нигде явно не задан метакласс, он использует инструкции базового метакласса ```type``` для создания класса.

Получается передав пользовательский метакласс при создании класса, можно изменить логику его создания.

Единственный пример, который приходит в голову, это реализация паттерна ```Singleton``` через метакласс.
## Singleton
Это паттерн проектирования, при котором использующий его класс может иметь лишь один экземпляр. Все попытки создания нового экземпляра, будут возвращать один и тот же ранее созданный экземпляр.

Самая удачная реализация происходит путем создания метакласса, где переопределяется метод ```__call__()```, так чтобы при каждом вызове класса (попытке создания нового экземпляра) возвращался ранее созданный.
### Как это работает в моем понимании
Интерпретатор видит, что при создании класса указан пользовательский метакласс. Он переходит туда и использует инструкции для создания класса указанные в нем. В этом случае переопределяется ```__call__()```, а все остальные методы наследуются от ```type```, значит остаются неизменными.
При первом вызове создается экземпляр и добавляется коллекцию. При последующих вызовах, возвращается элемент коллекции.